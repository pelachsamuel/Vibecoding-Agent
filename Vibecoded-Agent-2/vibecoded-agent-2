import os
import math
import json
import yfinance as yf
from google import genai
from google.genai import types
from dotenv import load_dotenv
from typing import List, Dict, Any, Union
from datetime import datetime, timedelta
import pandas as pd # Importujeme, hoci je to hlavne pre internú prácu yfinance

# Load environment variables
load_dotenv()

# --- Nastavenie a Inicializácia ---

# Inicializujte Gemini klienta
# Poznámka: Očakáva GEMINI_API_KEY v súbore .env
api_key = os.environ.get("GEMINI_API_KEY")
if not api_key:
    # Ak kľúč nie je nájdený, vyhodíme chybu pre používateľa
    raise ValueError("GEMINI_API_KEY nie je nájdený. Skontrolujte súbor .env.") 
client = genai.Client(api_key=api_key)

# --- Tool Function Implementations (Python Logika) ---

def get_current_price(ticker: str) -> Dict[str, Union[str, float, None]]:
    """
    Získa aktuálnu obchodnú cenu pre daný ticker (dnešná valuácia).
   
    
    Args:
        ticker: Symbol akcie, napr. 'GOOGL', 'NVDA'.

    Returns:
        Slovník s tickerom a aktuálnou cenou.
    """
    try:
        # yfinance.Ticker() získava aktuálne dáta
        ticker_info = yf.Ticker(ticker).info
        current_price = ticker_info.get("currentPrice")
        
        return {"ticker": ticker, "current_price": current_price}
    except Exception as e:
        return {"error": f"Nepodarilo sa získať aktuálnu cenu pre {ticker}. Detaily: {str(e)}"}


def get_yesterday_close(ticker: str) -> Dict[str, Union[str, float, None]]:
    """
    Získa záverečnú cenu akcie z predchádzajúceho obchodného dňa (včerajšia valuácia).
    Používame .item() na konverziu z pandas Series na Python float,
    aby sme sa vyhli chybe serializácie JSON.
   
    
    Args:
        ticker: Symbol akcie, napr. 'GOOGL', 'NVDA'.

    Returns:
        Slovník s tickerom, dátumom a záverečnou cenou z predchádzajúceho dňa.
    """
    try:
        # Stiahnite si históriu za posledných 5 dní
        history = yf.download(ticker, period="5d", interval="1d")
        
        if history.empty or len(history) < 2:
            return {"error": f"Nenašli sa dostatočné historické dáta pre {ticker}."}

        # Získajte predposlednú záverečnú cenu (predchádzajúci obchodný deň)
        # Používame .item() na konverziu z pandas Series na FLOAT.
        yesterday_close_value = history['Close'].iloc[-2].item() 
        yesterday_date = history.index[-2].strftime('%Y-%m-%d')
        
        return {
            "ticker": ticker, 
            "yesterday_date": yesterday_date, 
            "yesterday_close": yesterday_close_value
        }
    except Exception as e:
        return {"error": f"Nepodarilo sa získať včerajšiu cenu pre {ticker}. Detaily: {str(e)}"}


# --- Tool Definitions (Gemini Schémy) ---

# Definujeme schémy pre oba nástroje
tools_schema = [
    {
        "name": "get_current_price",
        "description": "Získa aktuálnu obchodnú cenu akcie (dnešná hodnota). Použite, keď je požadovaná dnešná cena.",
        "parameters": {
            "type": "object",
            "properties": {
                "ticker": {"type": "string", "description": "Symbol akcie (napr. MSFT, NVDA, PLTR)."},
            },
            "required": ["ticker"],
        },
    },
    {
        "name": "get_yesterday_close",
        "description": "Získa záverečnú cenu akcie z predchádzajúceho obchodného dňa (včerajšia hodnota). Použite na porovnanie cien v priebehu času.",
        "parameters": {
            "type": "object",
            "properties": {
                "ticker": {"type": "string", "description": "Symbol akcie (napr. MSFT, NVDA, PLTR)."},
            },
            "required": ["ticker"],
        },
    },
]

# Mapovanie názvu funkcie na skutočnú Python funkciu
available_functions = {
    "get_current_price": get_current_price,
    "get_yesterday_close": get_yesterday_close,
}

# Konfigurácia nástrojov pre Gemini
gemini_tools = types.Tool(function_declarations=tools_schema)


class GeminiReactAgent:
    """
    ReAct (Reason and Act) agent pre finančnú analýzu.
   
    """
    
    def __init__(self, model: str = "gemini-2.5-flash"):
        self.model = model
        self.max_iterations = 10
        
    def run(self, initial_query: str) -> str:
        """
        Spustí ReAct cyklus.
        """
        iteration = 0
        # Začíname s Content objektom pre užívateľskú otázku
        contents: List[types.Content] = [
            types.Content(role="user", parts=[types.Part.from_text(text=initial_query)])
        ] 
        
        while iteration < self.max_iterations:
            iteration += 1
            print(f"\n--- Iterácia {iteration} ---")
            
            # Konfigurácia s nástrojmi
            config = types.GenerateContentConfig(tools=[gemini_tools])
            
            # Zavolajte LLM (Reason or Act)
            response = client.models.generate_content(
                model=self.model,
                contents=contents,
                config=config,
            )
            
            # 1. Získanie volania funkcií
            function_calls: List[types.FunctionCall] = []
            
            if response.candidates and response.candidates[0].content and response.candidates[0].content.parts:
                for part in response.candidates[0].content.parts:
                    if hasattr(part, 'function_call') and part.function_call:
                        function_calls.append(part.function_call)
            
            has_function_calls = len(function_calls) > 0
            
            if has_function_calls:
                # 2. Pridajte požiadavku modelu do kontextu
                contents.append(response.candidates[0].content)
                
                # 3. Spracujte VŠETKY volania nástrojov
                function_responses: List[types.FunctionResponse] = []
                for function_call in function_calls:
                    function_name = function_call.name
                    function_args = dict(function_call.args)
                    
                    print(f"Executujem nástroj: {function_name}({function_args})")
                    
                    # Zavolajte Python funkciu
                    function_to_call = available_functions.get(function_name)
                    
                    if function_to_call:
                        tool_result = function_to_call(**function_args)
                    else:
                        tool_result = {"error": f"Neznáma funkcia: {function_name}"}
                    
                    print(f"Výsledok nástroja: {tool_result}")
                    
                    # Vytvorte odpoveď pre Gemini
                    func_response = types.FunctionResponse(
                        name=function_name,
                        response=tool_result
                    )
                    function_responses.append(func_response)
                
                # Pridajte odpovede nástrojov (Observation) späť do kontextu
                contents.append(types.Content(
                    role="tool", 
                    parts=[types.Part(function_response=fr) for fr in function_responses]
                ))
                
                # Pokračujte v cykle
                continue
                
            else:
                # 4. Žiadne volania funkcií – máme finálnu odpoveď
                final_content = response.text
                
                print(f"\nFinálna odpoveď: {final_content}")
                return final_content
        
        return "Chyba: Dosiahnuté maximum iterácií bez finálnej odpovede."


def main():
    # Vytvorte agenta
    agent = GeminiReactAgent()
    
    # Otázka, ktorá vyžaduje viacnásobné (sekvenčné) volania nástrojov:
    print("="*80)
    print("=== Otázka: Porovnanie cien NVDA a PLTR (Dnes vs. Včera) ===")
    print("="*80)
    query = "Aká je aktuálna valuácia Nvidie (NVDA) a Palantiru (PLTR)? Porovnaj ich s včerajšou záverečnou cenou a povedz mi, ktorá akcia dnes stúpla a o koľko (v USD), alebo klesla."
    result = agent.run(query)
    
    print("\n\n" + "="*80)
    print(f"FINÁLNY VÝSLEDOK AGENTA:\n{result}")
    print("="*80)
    

if __name__ == "__main__":
    main()